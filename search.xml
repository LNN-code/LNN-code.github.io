<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/10/25/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h1><ul>
<li><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><p><a href="#CPU利用率">CPU利用率</a></p>
</li>
<li><p><a href="#系统吞吐量">系统吞吐量</a></p>
</li>
<li><p><a href="#周转时间">周转时间</a></p>
</li>
<li><p><a href="#等待时间">等待时间</a></p>
</li>
<li><p><a href="#响应时间">响应时间</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p>CPU利用率：指CPU“忙碌”的时间占总时间的比例。</p>
<script type="math/tex; mode=display">
利用率=\frac{忙碌的时间}{总时间}</script><p><img src="https://i.loli.net/2021/10/25/qNiokeCWAmBQjJL.png" alt="image.png"></p>
<h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><p>系统吞吐量：单位时间内完成作业的数量</p>
<script type="math/tex; mode=display">
系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}</script><p><img src="https://i.loli.net/2021/10/25/4hwXRDIcQkCKVNT.png" alt="image.png"></p>
<h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2><p>周转时间：指从<strong>作业被提交给系统</strong>开始，到<strong>作业完成为止</strong>的这段时间间隔。</p>
<p><img src="https://i.loli.net/2021/10/25/rtxZ61BEsXQSecY.png" alt="image.png"></p>
<script type="math/tex; mode=display">
作业周转时间=作业完成时间-作业提交给系统的时间</script><script type="math/tex; mode=display">
平均周转时间=\frac{各作业周转时间之和}{作业数}</script><script type="math/tex; mode=display">
带权周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交给系统的时间}{作业实际运行时间}</script><script type="math/tex; mode=display">
平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}</script><h2 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h2><p>等待时间：指作业/进程<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低</p>
<h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>响应时间：指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/23/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><ul>
<li>目录<ul>
<li><a href="#***先来先服务（FCFS，first come first serve）***">先来先服务（FCFS）</a></li>
<li><a href="#***短作业优先（SJF，shortest job first）***">短作业优先（SJF）</a></li>
<li><a href="#高响应比优先（HRRN，highest response ratio next）">高响应比优先（HRRN）</a></li>
<li><a href="#***时间片轮转（RR，round-robin）***">时间片轮转（RR）</a></li>
<li><a href="#优先级调度算法">优先级调度算法</a></li>
<li><a href="#多级反馈队列调度算法">多级反馈队列调度算法</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips：各种调度算法的学习思路：</p>
<p>1.算法思想</p>
<p>2.算法规则</p>
<p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>4.抢占式还是非抢占式</p>
<p>5.优缺点</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
</blockquote>
<h2 id="先来先服务（FCFS，first-come-first-serve）"><a href="#先来先服务（FCFS，first-come-first-serve）" class="headerlink" title="先来先服务（FCFS，first come first serve）"></a><strong><em>先来先服务（FCFS，first come first serve）</em></strong></h2><p>1.算法思想：</p>
<p>​        主要从“公平”的角度考虑（类似于生活中排队买东西）</p>
<p>2.算法规则：</p>
<p>​        按照作业/进程到达的先后顺序进行服务，事实上等待时间越久的越优先得到服务</p>
<p>3.这种调度算法是用于作业调度还是进程调度：</p>
<p>​        用于进程调度时：考虑哪个进程先到达就绪队列。</p>
<p>​        用于作业调度时：考虑哪个作业先到达后备队列。</p>
<p>4.抢占式还是非抢占式：</p>
<p>​        非抢占式的算法</p>
<p>5.优缺点：</p>
<p>​        优点：公平，算法实现简单</p>
<p>​        缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好（<strong>简单点：对于长作业有利，对短作业不利</strong>）</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）：</p>
<p>​        不会导致饥饿。</p>
<p><img src="https://i.loli.net/2021/10/23/b8Bv3qo2YHG1jyI.png" alt="image.png"></p>
<h2 id="短作业优先（SJF，shortest-job-first）"><a href="#短作业优先（SJF，shortest-job-first）" class="headerlink" title="短作业优先（SJF，shortest job first）"></a><strong><em>短作业优先（SJF，shortest job first）</em></strong></h2><p>1.算法思想</p>
<p>​        追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</p>
<p>2.算法规则</p>
<p>​        最短作业/进程优先得到服务（最短：服务时间最短）</p>
<p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>​        用于进程调度时：称为“短进程优先算法”</p>
<p>​        用于作业调度时：</p>
<p>4.抢占式还是非抢占式</p>
<p>​        SJF和SPF是非抢占式算法，但也有抢占式的版本“最短剩余时间优先算法（SRTN）”</p>
<p>5.优缺点</p>
<p>​        优点：“最短的”平均等待时间，平均周转时间</p>
<p>​        缺点：不公平，<strong>对短作业有利，对长作业不利</strong>。可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
<p>​        会，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“<strong>饥饿</strong>”现象。如果一直得不到服务，则称为“<strong>饿死</strong>”</p>
<p><strong>非抢占式：</strong></p>
<p><img src="https://i.loli.net/2021/10/23/XCSWeRjyomK52N9.png" alt="image.png"></p>
<p><strong>抢占式：</strong></p>
<p><img src="https://i.loli.net/2021/10/23/WPQitrHOBCX9vEn.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/10/23/6zo4krbvBxTtWLH.png" alt="image.png"></p>
<p>Note：</p>
<p>1.如果题目中<strong>未特别说明</strong>，所提到的“短作业/进程优先算法”<strong>默认</strong>是<strong>非抢占式</strong>的</p>
<p>2.“SJF调度算法的平均等待时间，平均周转时间最少”——-该说法不严谨</p>
<p>严谨说法：</p>
<p>“在<strong>所有进程同时可运行</strong>时，采用SJF调度算法的平均等待时间，平均周转时间最少”或</p>
<p>“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间，平均周转时间最少”或</p>
<p>“<strong>抢占式</strong>的短作业/进程优先调度算法（<strong>最短剩余时间优先，SRNT</strong>算法）的平均等待时间，平均周转时间最少”</p>
<p>3.虽然严格来说，SJF的平均等待时间，平均周转时间并不一定最少，但相比与其他算法（如：FCFS），SJF依然可以获得较少的平均等待时间，平均周转时间。</p>
<p>4.如果选择题中遇到“SJF算法的平均等待时间，平均周转时间最少”的选项 ，那最好判断其他选项，是不是有很明显的错误，如果没用更合适的选项，那也应该选择该选项。</p>
<h2 id="高响应比优先（HRRN，highest-response-ratio-next）"><a href="#高响应比优先（HRRN，highest-response-ratio-next）" class="headerlink" title="高响应比优先（HRRN，highest response ratio next）"></a><strong><em>高响应比优先（HRRN，highest response ratio next）</em></strong></h2><p>1.算法思想</p>
<p>​        要综合考虑作业/进程的等待时间和要求服务时间</p>
<p>2.算法规则</p>
<p>​        在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务</p>
<p>​        </p>
<script type="math/tex; mode=display">
响应比=\frac{等待时间+要求服务时间}{要求服务时间} \ge 1</script><p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>​        即可用于作业调度，也可用于进程调度。</p>
<p>4.抢占式还是非抢占式</p>
<p>​        <strong>非抢占式</strong>算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应         比。</p>
<p>5.优缺点</p>
<p>​        优点：综合考虑等待时间和运行时间（要求服务时间）</p>
<p>​                    等待时间相同时，要求服务时间最短的优先（SJF的优点）</p>
<p>​                    要求服务时间相同时，等待时间长的优先（FCFS的优点）</p>
<p>​                    对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥                    饿的问题</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
<p>​    不会导致饥饿</p>
<p><img src="https://i.loli.net/2021/10/23/rJVfvLbXDHgapdS.png" alt="image.png"></p>
<h2 id="时间片轮转（RR，round-robin）"><a href="#时间片轮转（RR，round-robin）" class="headerlink" title="时间片轮转（RR，round-robin）"></a><strong><em>时间片轮转（RR，round-robin）</em></strong></h2><p>1.算法思想</p>
<p>​        公平地，轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
<p>2.算法规则</p>
<p>​        按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如：100ms）。若进程未        在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p>
<p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>​        用于调度进程（只用作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p>
<p>4.抢占式还是非抢占式</p>
<p>​        若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占        式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</p>
<p>5.优缺点</p>
<p>​        优点：公平，响应快，适用于分时操作系统</p>
<p>​        缺点：由于高频率进程的切换，因此有一定的系统开销，不区分任务的紧急程度</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
<pre><code>     不会导致饥饿
</code></pre><p><img src="https://i.loli.net/2021/10/24/fqAphDa9rkZKIQn.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/10/24/ErlOj96xesRKkty.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/10/24/PSfq6JhxFdbQeLV.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/10/24/u41mEwySW5KMzXc.png" alt="image.png"></p>
<p>Note：时间片太大或太小分别有什么影响（选择题）</p>
<p>​        如果<strong>时间片太大</strong>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且<strong>会增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。</p>
<p>​        另一方面，进程调度，切换是有时间代价的（保存，恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。</p>
<h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>1.算法思想</p>
<p>​        随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来        决定处理顺序</p>
<p>2.算法规则</p>
<p>​        每个作业/进程有各自的优先级。调度时选择优先级最高的作业/进程</p>
<p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>​        即可用于作业调度，也可用于进程调度。甚至，还会用于在之后学习的I/O调度中</p>
<p>4.抢占式还是非抢占式</p>
<p>​        抢占式，非抢占式都有。</p>
<p>​        做题时的区别在于：非抢占式只需要在进程主动放弃处理机时进行调度即可。而抢占式还需在就绪        队列变化时，检查是否会发生抢占。</p>
<p>5.优缺点</p>
<p>​        优点：用优先级区分紧急程度，重要程度。适用于实时操作系统。可灵活地调整对各种作业/进程                  的偏好程度。</p>
<p>​        缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
<pre><code>     会发生饥饿
</code></pre><p><img src="https://i.loli.net/2021/10/24/NQ1YqOCF3APDM49.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/10/24/TgSlXmaHDcrVN75.png" alt="image.png"></p>
<p>Note：</p>
<p>​        就绪队列未必只有一个，可以按照不同优先级来组织 。另外，也可以把优先级高的进程排在更靠近队头的位置。</p>
<p>​        根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong></p>
<p>​        静态优先级：创建进程时确定，之后一直不变。</p>
<p>​        动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级</p>
<p>如何合理地设置各类进程的优先级？</p>
<p>​        通常： 系统进程 &gt; 用户进程</p>
<p>​                    前台进程 &gt; 后台进程</p>
<p>​                    操作系统更偏好I/O进程（I/O繁忙型进程）</p>
<p>如果采用的是动态优先级，什么时候应该调整？</p>
<p>​        可以从追求公平。提升资源利用率等角度考虑。</p>
<p>​        如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</p>
<p>​        如果某进程占用处理机运行了很长时间，则可适当降低其优先级</p>
<p>​        如果发现一个进程频繁地进行I/O操作，则适当提升其优先级</p>
<h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>1.算法思想</p>
<p>​        对以上算法的折中权衡</p>
<p>2.算法规则</p>
<p>​        1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p>
<p>​        2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结           束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</p>
<p>​        3.只有第K级队列为空时，才会为K+1级队头的进程分配时间片。</p>
<p>3.这种调度算法是用于作业调度还是进程调度</p>
<p>​        用于进程调度</p>
<p>4.抢占式还是非抢占式</p>
<p>​        抢占式算法。在K级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则        由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回K级队列的        队尾</p>
<p>5.优缺点</p>
<p>6.是否会导致饥饿（饥饿：某进程/作业长期得不到服务）</p>
<p>​        会导致饥饿</p>
<p><img src="https://i.loli.net/2021/10/24/ZNuC1bncA4oxBgO.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2021/10/17/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>线程</strong>——比进程更小的能<strong>独立运行</strong>的基本单位</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>定义：是作为调度和分派的基本单位，不同时作为拥有资源的单位</p>
<p>目的：是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性</p>
<h2 id="线程与进程（理解为：继承父子关系）"><a href="#线程与进程（理解为：继承父子关系）" class="headerlink" title="线程与进程（理解为：继承父子关系）"></a>线程与进程（理解为：继承父子关系）</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/08/JSP%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>title: JSP语法<br>date: 2021-10-08 10:43:23<br>tags:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;);</span><br><span class="line"> %&gt;</span><br></pre></td></tr></table></figure>
<p>response处理用户请求;</p>
<p>sendRedirect()函数的作用是重定向网页，向浏览器发送一个特殊的Header，然后由浏览器来做重定向，转到指定的页面;</p>
<p>request是获取用户的请求;</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Servlet类"><a href="#Servlet类" class="headerlink" title="Servlet类"></a>Servlet类</h2><p>Servlet的类就是编写一个特殊类“HttpServlet”（javax.servlet.http包中的HttpServlet）的子类。</p>
<p>HttpServlet实现了Servlet接口，实现了响应用户的方法。</p>
<p>为了便于Web应用程序的管理，Servlet类应该具有包（package）名</p>
<h2 id="字节码文件的保存"><a href="#字节码文件的保存" class="headerlink" title="字节码文件的保存"></a>字节码文件的保存</h2><p>为了能让Tomcat服务器使用某个java类创建一个Servlet，需要将该java类源文件产生的 .class 字节码文件按照类的包名对应的目录路径保存到Web服务目录中的特定子目录（<strong>保存到WEB-INF\classes\包名</strong>）</p>
]]></content>
  </entry>
  <entry>
    <title>VScode创建JSP项目</title>
    <url>/2021/10/07/VScode%E5%88%9B%E5%BB%BAJSP%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="在vscode中按下ctrl-shift-p-输入maven点击下图指出项-上图-或者在工作区右键选择-下图"><a href="#在vscode中按下ctrl-shift-p-输入maven点击下图指出项-上图-或者在工作区右键选择-下图" class="headerlink" title="在vscode中按下ctrl+shift+p, 输入maven点击下图指出项(上图)或者在工作区右键选择(下图)"></a>在vscode中按下ctrl+shift+p, 输入maven点击下图指出项(上图)或者在工作区右键选择(下图)</h2><p><img src="https://i.bmp.ovh/imgs/2021/10/114e7d1ea404202f.png" alt=""></p>
<p><img src="https://i.bmp.ovh/imgs/2021/10/7b84f1fbd84f1151.png" alt=""></p>
<h2 id="输入web，选择maven-archetype-webapp回车"><a href="#输入web，选择maven-archetype-webapp回车" class="headerlink" title="输入web，选择maven-archetype-webapp回车"></a>输入web，选择maven-archetype-webapp回车</h2><p><a href="https://imgtu.com/i/59mF4f"><img src="https://z3.ax1x.com/2021/10/07/59mF4f.png" alt="59mF4f.png"></a></p>
<h2 id="选择1-4"><a href="#选择1-4" class="headerlink" title="选择1.4"></a>选择1.4</h2><p><img src="https://i.bmp.ovh/imgs/2021/10/d5f288f88b08594b.png" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
  </entry>
  <entry>
    <title>偏导数</title>
    <url>/2021/10/06/%E5%81%8F%E5%AF%BC%E6%95%B0/</url>
    <content><![CDATA[<p>Q：什么是增量？</p>
<p>A：当平面上一个质点从一点移动到另一点，其坐标的纯改变或增量通过把<strong>终点坐标减去起点坐标</strong>而求得。</p>
<h2 id="此节会用到的增量"><a href="#此节会用到的增量" class="headerlink" title="此节会用到的增量"></a>此节会用到的增量</h2><script type="math/tex; mode=display">
F(x,y)在M_{0}处关于x的偏增量：</script><script type="math/tex; mode=display">
\Delta Zx=f(x_{0} +\Delta x ,y_{0})-f(x_{0},y_{0}) 或f(x,y_{0})-f(x_{0},y_{0})</script><script type="math/tex; mode=display">
F(x,y)在M_{0}处关于y的偏增量：</script><script type="math/tex; mode=display">
\Delta Zy=f(x_{0} ,y_{0}+\Delta y)-f(x_{0},y_{0}) 或f(x_{0},y)-f(x_{0},y_{0})</script><script type="math/tex; mode=display">
F(x,y)在M_{0}处的全增量</script><script type="math/tex; mode=display">
\Delta Z=f(x_{0}+\Delta x ,y_{0}+\Delta y)-f(x_{0},y_{0}) 或f(x,y)-f(x_{0},y_{0})</script><h1 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h1><p>定义：</p>
<script type="math/tex; mode=display">
z=f(x,y){\color{Blue} } ,((x，y)\in D,f(x,y)在(x,y)处对x,y皆可偏导，称 ，IF \forall (x_{0},y_{0})\in D,f(x,y)在(x,y)处对x,y皆可偏导，称{fx}' (x,y),{fy}' (x,y)为f(x,y)对x,y的偏导数，称为偏导数</script><p>已知：</p>
<script type="math/tex; mode=display">
z=f(x,y){\color{Blue} } ,((x，y)\in D ),M_{0}(x_{0},y_{0})</script><script type="math/tex; mode=display">
IF \lim_{\Delta x \to 0} \frac{\Delta Z_{x} }{\Delta x} \quad \exists \quad称f(x,y)在M_{0}处关于x可偏导，极限值称为f(x,y)在M_{0}处关于x的偏导数，记：\\{fx}' (x_{0},y_{0})
，\frac{\partial z}{\partial x} |_{(x_{0},y_{0})}</script><script type="math/tex; mode=display">
IF \lim_{\Delta y \to 0} \frac{\Delta Z_{y} }{\Delta y}\quad \exists\quad 称f(x,y)在M_{0}处关于y可偏导，极限值称为f(x,y)在M_{0}处关于y的偏导数，记：\\{fy}' (x_{0},y_{0})
，\frac{\partial z}{\partial y} |_{(x_{0},y_{0})}</script><p>简记为：</p>
<script type="math/tex; mode=display">
\lim_{\Delta x \to 0} \frac{\Delta Z_{x} }{\Delta x}={fx}' (x_{0},y_{0})
，\frac{\partial z}{\partial x} |_{(x_{0},y_{0})}</script><script type="math/tex; mode=display">
\lim_{\Delta y \to 0} \frac{\Delta Z_{y} }{\Delta y}={fy}' (x_{0},y_{0})
，\frac{\partial z}{\partial y} |_{(x_{0},y_{0})}</script><p><strong>解法：</strong></p>
<p>​        <strong>求x的偏导数时，将所求式子中除了x以外的未知数全部当作常数进行求导</strong></p>
<p>​        <strong>求y的偏导数时，将所求式子中除了y以外的未知数全部当作常数进行求导</strong></p>
<p>​        <strong>求偏导数就是求出x的偏导数和y的偏导数</strong></p>
<h1 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h1><h3 id="二阶偏导数求解："><a href="#二阶偏导数求解：" class="headerlink" title="二阶偏导数求解："></a>二阶偏导数求解：</h3><p>​            解法：</p>
<script type="math/tex; mode=display">
1.先求\quad\frac{\partial z}{\partial x}，\frac{\partial z}{\partial y}</script><script type="math/tex; mode=display">
2.再求\quad\frac{\partial^{2}z}{\partial x^{2}} ，\frac{\partial^{2}z}{\partial y^{2}} ,\frac{\partial^{2}z}{\partial x\partial y} ,\frac{\partial^{2}z}{\partial y\partial x}</script>]]></content>
      <categories>
        <category>高等数学</category>
      </categories>
      <tags>
        <tag>多元函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo创建并发布博客</title>
    <url>/2021/09/26/Hexo%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>首先按win+r，输入cmd进入cmd界面</p>
<p><img src="https://i.loli.net/2021/09/26/nRaxrCOS7l5vhze.png" alt="image.png"></p>
<p>进入之后，直接输入你博客所在的磁盘盘符（C盘，D盘等），并按下回车建，进入目标磁盘的根目录</p>
<p>ps:由于我放在”I盘”中，所以我要输入” i：“</p>
<p><img src="https://i.loli.net/2021/09/26/fz6rivQBHt3aKY7.png" alt="image.png"></p>
<p>随后输入 cd   博客项目文件夹   <strong>(注：cd 后一定要有空格)</strong></p>
<p><img src="https://i.loli.net/2021/09/26/MpXrKFh1Ume5S6l.png" alt="image.png"></p>
<p>进入到项目的根目录之后就可以输入以下代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#新建博客</span><br><span class="line">hexo new &quot;博客标题&quot;</span><br><span class="line"></span><br><span class="line">#运行本地服务(预览你的博客)</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">#生成静态文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">#完成部署</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">#清除缓存文件和已生成的静态文件</span><br><span class="line">hexo clean</span><br><span class="line">//在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
